<html>
	<head>
	</head>
	<body>
		<h1> Overview </h1>
		In this homework, I implemented some basic algorithms for geometry processing. 

		<h1> Task 1 </h1>
		For this task I implemented de Casteljau's algorithm for Bezier curve evaluation. A simple description of the algorithm is as follows- <br>
		Given a set of n control points (say stored in a length n array called Control_points) and a parameter t, we recursively compute an array of length n-1 <br>
		Where the i-th  element of the array is given by t*Control_points[i+1] + (1-t)*Control_points[i]. this recursive step is coded in the function BezierCurve::evaluateStep() <br>
		We then recursively call this function n times until we are left with one element. This last element, along with the first and last of our control points are then used <br>
		to construct a cubic polynomial. One can also use piecewise interpolation when we have a large number of points that are arranged in a jagged maner - i.e, we'd divide <br> 
		the array into k contiguous sub-arrays of length n/k and then form cubic polynomials for each sub-array. We'd then connect the polynomial from each sub-array. <br>
		Below I've presented some images of a curve formed with 6 control points stored in m_curve.bzc <br>
		<img src="Screen Shot 2024-02-27 at 8.47.19 PM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-27 at 8.48.28 PM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-27 at 8.49.07 PM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-27 at 8.49.43 PM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-27 at 8.50.37 PM.png" 
     width="300" 
     height="300" />
		<br>
		Here are splines for slughlty modified set of points and a different value of t
		<br><br><br>
		<img src="Screen Shot 2024-02-28 at 12.31.10 AM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-28 at 12.31.27 AM.png" 
     width="300" 
     height="300" />




		<h2> Task 2</h2>
		Before the explanation, here is an image of the rendered pot <br>
		<img src="Screen Shot 2024-02-27 at 8.57.24 PM.png" 
     width="400" 
     height="500" />
		<br>
		<br>
		<br>
		
		Bezier curves genenralize to surfaces in an intuitive way. If we are given a grid of n*n control points, we look at the grid column-by-column first. <br>
		Apply the above recursive algorithm with each column using t=u. Then, we would have condensed an n*n grid into n points - one final point for each column. <br>
		After that, we perform de Casteljau on the newly derived n points, but now using t=v. <br>
		In the code implementation, the evaluateId function deals with a column of n points. So, we first call that on each of our n columns with t = u. <br>
		Further, we store the results of each of the above computations in a std::vec. This array will be length n. We then call evaluateId on this new array with t=v. <br>


		<h3> Task 3 </h3>
		Again, here's the images before the explanation. The images arre with shader on and off respectively <br>
		<img src="Screen Shot 2024-02-27 at 9.02.29 PM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-27 at 9.03.11 PM.png" 
     width="300" 
     height="300" />
		<br>
		<br>
		<br>
		
		The algorihtm to compute weighted normal is as follows-
		First, note that since every element is just a triangle, we can calculate it's area as a*b*sin(theta)/2 or just 0.5*cross(a,b). <br>
		So we just need to calculate the vectors for a and b and then plug it into the given cross function. So, we can iterate through all neighbor <br>
		faces, get the vector of two edges of the traingle, then add this cross product to a running sum which starts at 0 vector. <br>
		After all that, normalize the vector by caling the unit() method. Below I've provided a diagram to complement the explanation
		<br><br><br>
		<img src="cross_prdt.png" 
     width="300" 
     height="300" />
		<br>
		<br>
		<br>
		
		



		<h4> Task 4</h4>
		Pictures - first is before flips, then is after<br>
		<img src="Screen Shot 2024-02-27 at 11.16.56 PM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-27 at 11.18.24 PM.png" 
     width="300" 
     height="300" />
		<br>
		<br>
		<br>

		For edge flip, the entire algorithm is just a lot of pointer reassignments. To implement it, I drew out the labelled images from the lecture slides. <br>
		One I had the labels of before and after, it was just a matter of collecting all the mesh elements and reassign. <br>
		First I got the half edge h0, and then with calls to next() and twin(), I got all the half edges in the "before" diagram. From the half edges, <br>
		I obtained all the edgeIters, faceIters and vertexIers with appropriate halfedge methods. After I collected everything, I just reasigned everything <br> 
		according the te "after" diagram using the setNeighbours() method for halfedges. For vertices, faces and edges, I just updated the halfedge by say _->halfedge() = h (h is the appropriate halfedge) <br>
		The before and after diagrams are shown below- <br> <br> <br>
		<img src="orig.png" 
     width="300" 
     height="300" />
		<img src="flip.png" 
     width="300" 
     height="300" />

		<br><br>
		


		<h5> Task 5</h5>
		Pictures - First is the vanilla pot, then is only with splits, then is splits and flips <br>
		<img src="Screen Shot 2024-02-27 at 11.21.55 PM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-27 at 11.22.45 PM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-27 at 11.24.07 PM.png" 
     width="300" 
     height="300" />

		<br><br><br>
		

		My method for edge split was very similar to edge flip. I drew out befores and afters and then collected all the halfedges with calls to next() and twin().<br>
		Then I collected all the other objects by using the "before" image. Thn, before starting pointer reassignment, I created all the new halfedges required, along with the new faces, new vertex and new edges. <br>
		Finally, I reassigned using set_Neighbours and _->halfedge() with the help of the "after" image. I also set vertex->position to be the midpoint of the edge we are splitting. <br>
		Midpoint was computed by as 0.5*(h->vertex()->position + h->twin()->vertex()->position)<br>
		Here is an image describing an approx transition. I've removed labels to avoid cluttering
		<br>
		<img src="orig.png" 
     width="300" 
     height="300" />
		<img src="split.png" 
     width="300" 
     height="300" />
		<br>
		<br>
		I also implemented splitting for edges. for that, Instead of the the conventional images, the new "before" image was just an iscosceles triangle - the after just had the traingle's altitude labelled.<br>
		Here is an approx image of the transition
		<img src="half_split.png" 
     width="300" 
     height="300" />

		<br><br>
		
		
		To check that it works, I used the "beetle" image, I've split some of the edges on the bottom boundary as seen below. <br>
		First image is without splits, second is with splits. <br>
		<img src="Screen Shot 2024-02-27 at 11.25.39 PM.png" 
     width="300" 
     height="300" />
		<img src="Screen Shot 2024-02-27 at 11.27.20 PM.png" 
     width="300" 
     height="300" />
			
		

		



		<h6> Task 6 </h6>
		Final task! This was implemented as suggested by the comments in the starter code. First I computed the new positions of all the vertices using the (1 - n * u) * original_position + u * original_neighbor_position_sum formula. <br>
		Wher u is 3/16 if the degree of the vertex is 3 and it is 3/8n otherwise (n is degree). I also marked each vertex by setting isNew to be false. <br>
		Then, I ran through all edges and computed their new position by using the (3(A+B) + C + D)/8 formula. I then split the edges all the old edges while mantaining an array of new_edges. <br>
		When we split one edge, we get two new ones, and two not really new ones since when you take the union of te two "not new" ones, you just get the old edge. <br>
		Keeping that in mind, I only add the truly new edges to the array of new edges. I then mark all the newly generated edges by setting isNew = true. <br>
		Also, for the newly obtained vertex, I set its position to be the newPosition of the edge that we split. <br>
		Finally, I iterate through the array of new_edges and flip all those edges that connect new vertices to old vertices (so isNew is true for one and not for the other). <br>
		After the flipping, I set vertex->position = vertex->newPosition for all old vertices.
		<br>
		The sharp edges and vertices get much smoother as we refine the mesh. This is easily seen in the cube. Below I've included images of a gradual transition- <br>
		<img src="Screen Shot 2024-02-28 at 12.01.55 PM.png" 
     width="150" 
     height="150" />
		<img src="Screen Shot 2024-02-28 at 12.02.20 PM.png" 
     width="150" 
     height="150" />
		<img src="Screen Shot 2024-02-28 at 12.02.33 PM.png" 
     width="150" 
     height="150" />
		<img src="Screen Shot 2024-02-28 at 12.02.45 PM.png" 
     width="150" 
     height="150" />
		<img src="Screen Shot 2024-02-28 at 12.02.58 PM.png"
			width="200"
			heigh="200" />

		<br>
		Then, to ensure that the cube splits symmetrically, I just split all the diagonals on all faces so that every face has an "X" mark. The resultant cube is symmetric. <br>
		<img src="Screen Shot 2024-02-28 at 12.03.43 PM.png" 
     width="200" 
     height="200" />
		<img src="Screen Shot 2024-02-28 at 12.03.59 PM.png" 
     width="200" 
     height="200" />
		<br> An intuitive explanation for this is as follows- When we don't have the X mark on every face, when we split and flip we have a bias in the direction opposite to the <br>
		direction of the diagonals since we don't flip the edges that conpose the original edge. Because of this, we have a slightly larger growth in one direction. <br>
		To ensure equal growth in both directions, we can just add a diagonal that goes the other way. This will give a bias to both directions, which evens out to give us a symmetric cube. <br>
		We can also go a step further and make a "*" mark instead of "X". <br>

		<br>
		<br>
		To increase sharpness of an edge, I found that it helps to keep splitting the diagonals of the faces incident on that edge. i.e, the more sub-faces a faces has, the sharper its edges become. <br>
		An example is displayed below where I formed the following pattern on all faces. <br>
		<img src="Screen Shot 2024-02-28 at 1.13.00 PM.png" 
     width="200" 
     height="200" />
		<br>
		<img src="Screen Shot 2024-02-28 at 1.13.39 PM.png" 
     width="200" 
     height="200" />
		<br>
		Finally, I made changes to account for boundary elements. For vertices, I update their new position to be 0.75*old_position + 0.125*(sum of positions of neighbouring boundary vertices) <br>
		Then for an edge (p0,p1) I set the newPostion to be 0.5*(old_pos of p0 + old_pos of p1) <br>
		Below I've pasted pictures of the refined and unrefined beetle to show how it works. <br>
		<img src="Screen Shot 2024-02-28 at 12.09.56 PM.png" 
     width="200" 
     height="200" />
		<br>
		<img src="Screen Shot 2024-02-28 at 12.10.11 PM.png" 
     width="200" 
     height="200" />
		<br>
		Finally, I also implemented root3 subdivision. For this, I had to define a new HalfEdgeMesh method called AddCentroid. This method takes in a FaceIter f and returns a VertexIter v3. <br>
		Its implementation is similar to that of split edge, where we make a few new objects and just perform pointer reassignments. The transition diagram is shown below. <br>
		<img src="tri.png" 
     width="200" 
     height="200" />
		<br>
		For the new position of the vertices, we use the formula (1 - alpha)*old_pos + alpha*sum_of_neighbours/n - where n is the degree and alpha = (4 - 2*cos(2pi/n))/9. <br>
		The position of new vertices is just the centroid and so it is just (p0 + p1 + p2)/3. <br>
		Now, the algorihtm proceeds as follows- <br>
		First mark all faces, edges and vertices to be old. <br>
		Then, compute new position of vertices as described above. <br>
		Next, call addCentroid on all the old faces, while marking the 3 newly obtained faces to be new. Also mark the edges belonging to the input face as being old and the other 3 edges as being new. Same for vertices <br>
		Assign the new vertex position to be the centroid of the input face. <br>
		Finally, flip all the old edges. <br>
		<br>
		Root3 subdivision seems to behave much more symmetrically than the vanilla subdivision scheme. This is to be expected since we are adding new points and edges in a more symmetric fashion since we use the centroid of every face <br>
		Here is an example of the refined cube.dae (without any modifications). While it is not entirely symmetric, it is more symmetric than the vanilla subdivision. <br>
		<img src="Screen Shot 2024-02-28 at 9.24.43 PM.png" 
     width="200" 
     height="200" />
		<br>
		Here is an example of a refined torus as well, and a cube with an "X" pattern on every face. The images shown are after 2 and 4 steps of refinement- <br>
		<img src="Screen Shot 2024-02-28 at 12.17.53 PM.png" 
     width="200" 
     height="200" />
		<br>
		<img src="Screen Shot 2024-02-28 at 12.17.38 PM.png" 
     width="200" 
     height="200" />
		<br>
		<img src="Screen Shot 2024-02-28 at 12.18.37 PM.png" 
     width="200" 
     height="200" />
		<br>
		<img src="Screen Shot 2024-02-28 at 12.18.50 PM.png" 
     width="200" 
     height="200" />
		<br>
		the new method can be tested by uncommenting the #define SQRT3 on top.
		
		
		
		


		

		
		
		
	</body>
</html>
