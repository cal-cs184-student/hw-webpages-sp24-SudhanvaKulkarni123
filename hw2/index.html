<html>
	<head>
	</head>
	<body>
		<h1> Overview </h1>
		In this homework, I implemented some basic algorithms for geometry processing. 

		<h1> Task 1 </h1>
		For this task I implemented de Casteljau's algorithm for Bezier curve evaluation. A simple description of the algorithm is as follows- <br>
		Given a set of n control points (say stored in a length n array called Control_points) and a parameter t, we recursively compute an array of length n-1 <br>
		Where the i-th  element of the array is given by t*Control_points[i+1] + (1-t)*Control_points[i]. this recursive step is coded in the function BezierCurve::evaluateStep() <br>
		We then recursively call this function n times until we are left with one element. This last element, along with the first and last of our control points are then used <br>
		to construct a cubic polynomial. One can also use piecewise interpolation when we have a large number of points that are arranged in a jagged maner - i.e, we'd divide <br> 
		the array into k contiguous sub-arrays of length n/k and then form cubic polynomials for each sub-array. We'd then connect the polynomial from each sub-array. <br>
		Below I've presented some images of a curve formed with 6 control points stored in m_curve.bzc <br>
		<img src="Screen Shot 2024-02-27 at 8.47.19 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 8.48.28 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 8.49.07 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 8.49.43 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 8.50.37 PM.png" 
     width="400" 
     height="500" />
		<br>
		Here are splines for slughlty modified set of points and a different value of t
		<img src="Screen Shot 2024-02-28 at 12.31.10 AM.png" 
     width="400" 
     height="500" />
		<img src="SScreen Shot 2024-02-28 at 12.31.27 AM.png" 
     width="400" 
     height="500" />




		<h2> Task 2</h2>
		Before the explanation, here is an image of the rendered pot <br>
		<img src="Screen Shot 2024-02-27 at 8.57.24 PM.png" 
     width="400" 
     height="500" />
		Bezier curves genenralize to surfaces in an intuitive way. If we are given a grid of n*n control points, we look at the grid column-by-column first. <br>
		Apply the above recursive algorithm with each column using t=u. Then, we would have condensed an n*n grid into n points - one final point for each column. <br>
		After that, we perform de Casteljau on the newly derived n points, but now using t=v. <br>
		In the code implementation, the evaluateId function deals with a column of n points. So, we first call that on each of our n columns with t = u. <br>
		Further, we store the results of each of the above computations in a std::vec. This array will be length n. We then call evaluateId on this new array with t=v. <br>


		<h3> Task 3 </h3>
		Again, here's the images before the explanation. The images arre with shader on and off respectively <br>
		<img src="Screen Shot 2024-02-27 at 9.02.29 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 9.03.11 PM.png" 
     width="400" 
     height="500" />
		The algorihtm to compute weighted normal is as follows-
		First, note that since every element is just a triangle, we can calculate it's area as a*b*sin(theta)/2 or just 0.5*cross(a,b). <br>
		So we just need to calculate the vectors for a and b and then plug it into the given cross function. So, we can iterate through all neighbor <br>
		faces, get the vector of two edges of the traingle, then add this cross product to a running sum which starts at 0 vector. <br>
		After all that, normalize the vector by caling the unit() method. Below I've provided a diagram to complement the explanation
		<img src="cross_prdt.png" 
     width="400" 
     height="500" />
		



		<h4> Task 4</h4>
		Pictures - first is before flips, then is after<br>
		<img src="Screen Shot 2024-02-27 at 11.16.56 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 11.18.24 PM.png" 
     width="400" 
     height="500" />

		For edge flip, the entire algorithm is just a lot of pointer reassignments. To implement it, I drew out the labelled images from the lecture slides. <br>
		One I had the labels of before and after, it was just a matter of collecting all the mesh elements and reassign. <br>
		First I got the half edge h0, and then with calls to next() and twin(), I got all the half edges in the "before" diagram. From the half edges, <br>
		I obtained all the edgeIters, faceIters and vertexIers with appropriate halfedge methods. After I collected everything, I just reasigned everything <br> 
		according the te "after" diagram using the setNeighbours() method for halfedges. For vertices, faces and edges, I just updated the halfedge by say _->halfedge() = h (h is the appropriate halfedge) <br>
		The before and after diagrams are shown below- <br> <br> <br>
		<img src="orig.png" 
     width="400" 
     height="500" />
		<img src="flip.png" 
     width="400" 
     height="500" />
		


		<h5> Task 5</h5>
		Pictures - First is the vanilla pot, then is only with splits, then is splits and flips <br>
		<img src="Screen Shot 2024-02-27 at 11.21.55 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 11.22.45 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 11.24.07 PM.png" 
     width="400" 
     height="500" />
		

		My method for edge split was very similar to edge flip. I drew out befores and afters and then collected all the halfedges with calls to next() and twin().<br>
		Then I collected all the other objects by using the "before" image. Thn, before starting pointer reassignment, I created all the new halfedges required, along with the new faces, new vertex and new edges. <br>
		Finally, I reassigned using set_Neighbours and _->halfedge() with the help of the "after" image. I also set vertex->position to be the midpoint of the edge we are splitting. <br>
		Midpoint was computed by as 0.5*(h->vertex()->position + h->twin()->vertex()->position)<br>
		Here is an image describing an approx transition. I've removed labels to avoid cluttering
		<br>
		<img src="orig.png" 
     width="400" 
     height="500" />
		<img src="split.png" 
     width="400" 
     height="500" />
		<br>
		<br>
		I also implemented splitting for edges. for that, Instead of the the conventional images, the new "before" image was just an iscosceles triangle - the after just had the traingle's altitude labelled.<br>
		Here is an approx image of the transition
		<img src="half_split.png" 
     width="400" 
     height="500" />
		
		
		To check that it works, I used the "beetle" image, I've split some of the edges on the bottom boundary as seen below. <br>
		First image is without splits, second is with splits. <br>
		<img src="Screen Shot 2024-02-27 at 11.25.39 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 11.27.20 PM.png" 
     width="400" 
     height="500" />
			
		

		



		<h6> Task 6 </h6>
		Final task! This was implemented as suggested by the comments in the starter code. First I computed the new positions of all the vertices using the (1 - n * u) * original_position + u * original_neighbor_position_sum formula. <br>
		Wher u is 3/16 if the degree of the vertex is 3 and it is 3/8n otherwise (n is degree). I also marked each vertex by setting isNew to be false. <br>
		Then, I ran through all edges and computed their new position by using the (3(A+B) + C + D)/8 formula. I then split the edges all the old edges while mantaining an array of new_edges. <br>
		When we split one edge, we get two new ones, and two not really new ones since when you take the union of te two "not new" ones, you just get the old edge. <br>
		Keeping that in mind, I only add the truly new edges to the array of new edges. I then mark all the newly generated edges by setting isNew = true. <br>
		Also, for the newly obtained vertex, I set its position to be the newPosition of the edge that we split. <br>
		Finally, I iterate through the array of new_edges and flip all those edges that connect new vertices to old vertices (so isNew is true for one and not for the other). <br>
		After the flipping, I set vertex->position = vertex->newPosition for all old vertices.
		<br>
		The sharp edges get much smoother as we refine the mesh. This is easily seen in the cintext of the cube. after playing around for a bit, I noticed I can increase the sharpness <br>
		at some given vertex by just increasing its degree. The evidence for that is seen in the pic  below where I concentrated all edges on one vertex-
<img src="Screen Shot 2024-02-27 at 11.53.12 PM.png" 
     width="400" 
     height="500" />
		


		<br>
		Then, to ensure that the cube splits symmetrically, I just split all the diagonals on all faces so that every face has an "X" mark. The resultant cube is symmetric. <br>
		<img src="Screen Shot 2024-02-27 at 11.49.09 PM.png" 
     width="400" 
     height="500" />
		<img src="Screen Shot 2024-02-27 at 11.49.27 PM.png" 
     width="400" 
     height="500" />
		


		
		
		
	</body>
</html>
